// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Proxy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Proxy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Proxy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021007 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Proxy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Proxy_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Proxy_2eproto;
class ClaimProxyConnMsg;
struct ClaimProxyConnMsgDefaultTypeInternal;
extern ClaimProxyConnMsgDefaultTypeInternal _ClaimProxyConnMsg_default_instance_;
class FreeProxyConnMsg;
struct FreeProxyConnMsgDefaultTypeInternal;
extern FreeProxyConnMsgDefaultTypeInternal _FreeProxyConnMsg_default_instance_;
class NetMsg;
struct NetMsgDefaultTypeInternal;
extern NetMsgDefaultTypeInternal _NetMsg_default_instance_;
class NewCtlReqMsg;
struct NewCtlReqMsgDefaultTypeInternal;
extern NewCtlReqMsgDefaultTypeInternal _NewCtlReqMsg_default_instance_;
class NewCtlRspMsg;
struct NewCtlRspMsgDefaultTypeInternal;
extern NewCtlRspMsgDefaultTypeInternal _NewCtlRspMsg_default_instance_;
class NewTunnelReqMsg;
struct NewTunnelReqMsgDefaultTypeInternal;
extern NewTunnelReqMsgDefaultTypeInternal _NewTunnelReqMsg_default_instance_;
class NewTunnelRspMsg;
struct NewTunnelRspMsgDefaultTypeInternal;
extern NewTunnelRspMsgDefaultTypeInternal _NewTunnelRspMsg_default_instance_;
class NotifyClientCreateProxyMsg;
struct NotifyClientCreateProxyMsgDefaultTypeInternal;
extern NotifyClientCreateProxyMsgDefaultTypeInternal _NotifyClientCreateProxyMsg_default_instance_;
class NotifyShutdownProxyMsg;
struct NotifyShutdownProxyMsgDefaultTypeInternal;
extern NotifyShutdownProxyMsgDefaultTypeInternal _NotifyShutdownProxyMsg_default_instance_;
class StartProxyReqMsg;
struct StartProxyReqMsgDefaultTypeInternal;
extern StartProxyReqMsgDefaultTypeInternal _StartProxyReqMsg_default_instance_;
class StartProxyRspMsg;
struct StartProxyRspMsgDefaultTypeInternal;
extern StartProxyRspMsgDefaultTypeInternal _StartProxyRspMsg_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ClaimProxyConnMsg* Arena::CreateMaybeMessage<::ClaimProxyConnMsg>(Arena*);
template<> ::FreeProxyConnMsg* Arena::CreateMaybeMessage<::FreeProxyConnMsg>(Arena*);
template<> ::NetMsg* Arena::CreateMaybeMessage<::NetMsg>(Arena*);
template<> ::NewCtlReqMsg* Arena::CreateMaybeMessage<::NewCtlReqMsg>(Arena*);
template<> ::NewCtlRspMsg* Arena::CreateMaybeMessage<::NewCtlRspMsg>(Arena*);
template<> ::NewTunnelReqMsg* Arena::CreateMaybeMessage<::NewTunnelReqMsg>(Arena*);
template<> ::NewTunnelRspMsg* Arena::CreateMaybeMessage<::NewTunnelRspMsg>(Arena*);
template<> ::NotifyClientCreateProxyMsg* Arena::CreateMaybeMessage<::NotifyClientCreateProxyMsg>(Arena*);
template<> ::NotifyShutdownProxyMsg* Arena::CreateMaybeMessage<::NotifyShutdownProxyMsg>(Arena*);
template<> ::StartProxyReqMsg* Arena::CreateMaybeMessage<::StartProxyReqMsg>(Arena*);
template<> ::StartProxyRspMsg* Arena::CreateMaybeMessage<::StartProxyRspMsg>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum MessageType : int {
  NewCtlReq = 0,
  NewCtlRsp = 1,
  NewTunnelReq = 2,
  NewTunnelRsp = 3,
  FreeProxyConn = 4,
  NotifyClientCreateProxy = 5,
  NotifyShutdownProxy = 6,
  ClaimProxyConn = 7,
  StartProxyReq = 8,
  StartProxyRsp = 9,
  HeartBeatReq = 10,
  HeartBeatRsp = 11,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = NewCtlReq;
constexpr MessageType MessageType_MAX = HeartBeatRsp;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class NetMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NetMsg) */ {
 public:
  inline NetMsg() : NetMsg(nullptr) {}
  ~NetMsg() override;
  explicit PROTOBUF_CONSTEXPR NetMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetMsg(const NetMsg& from);
  NetMsg(NetMsg&& from) noexcept
    : NetMsg() {
    *this = ::std::move(from);
  }

  inline NetMsg& operator=(const NetMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetMsg& operator=(NetMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetMsg* internal_default_instance() {
    return reinterpret_cast<const NetMsg*>(
               &_NetMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NetMsg& a, NetMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(NetMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetMsg& from) {
    NetMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NetMsg";
  }
  protected:
  explicit NetMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewCtlReqFieldNumber = 2,
    kNewCtlRspFieldNumber = 3,
    kNewTunnelReqFieldNumber = 4,
    kNewTunnelRspFieldNumber = 5,
    kFreeProxyConnFieldNumber = 6,
    kNotifyClientCreateProxyFieldNumber = 7,
    kNotifyShutdownProxyFieldNumber = 8,
    kClaimProxyConnFieldNumber = 9,
    kStartProxyReqFieldNumber = 10,
    kStartProxyRspFieldNumber = 11,
    kMessageTypeFieldNumber = 1,
  };
  // optional .NewCtlReqMsg newCtlReq = 2;
  bool has_newctlreq() const;
  private:
  bool _internal_has_newctlreq() const;
  public:
  void clear_newctlreq();
  const ::NewCtlReqMsg& newctlreq() const;
  PROTOBUF_NODISCARD ::NewCtlReqMsg* release_newctlreq();
  ::NewCtlReqMsg* mutable_newctlreq();
  void set_allocated_newctlreq(::NewCtlReqMsg* newctlreq);
  private:
  const ::NewCtlReqMsg& _internal_newctlreq() const;
  ::NewCtlReqMsg* _internal_mutable_newctlreq();
  public:
  void unsafe_arena_set_allocated_newctlreq(
      ::NewCtlReqMsg* newctlreq);
  ::NewCtlReqMsg* unsafe_arena_release_newctlreq();

  // optional .NewCtlRspMsg newCtlRsp = 3;
  bool has_newctlrsp() const;
  private:
  bool _internal_has_newctlrsp() const;
  public:
  void clear_newctlrsp();
  const ::NewCtlRspMsg& newctlrsp() const;
  PROTOBUF_NODISCARD ::NewCtlRspMsg* release_newctlrsp();
  ::NewCtlRspMsg* mutable_newctlrsp();
  void set_allocated_newctlrsp(::NewCtlRspMsg* newctlrsp);
  private:
  const ::NewCtlRspMsg& _internal_newctlrsp() const;
  ::NewCtlRspMsg* _internal_mutable_newctlrsp();
  public:
  void unsafe_arena_set_allocated_newctlrsp(
      ::NewCtlRspMsg* newctlrsp);
  ::NewCtlRspMsg* unsafe_arena_release_newctlrsp();

  // optional .NewTunnelReqMsg newTunnelReq = 4;
  bool has_newtunnelreq() const;
  private:
  bool _internal_has_newtunnelreq() const;
  public:
  void clear_newtunnelreq();
  const ::NewTunnelReqMsg& newtunnelreq() const;
  PROTOBUF_NODISCARD ::NewTunnelReqMsg* release_newtunnelreq();
  ::NewTunnelReqMsg* mutable_newtunnelreq();
  void set_allocated_newtunnelreq(::NewTunnelReqMsg* newtunnelreq);
  private:
  const ::NewTunnelReqMsg& _internal_newtunnelreq() const;
  ::NewTunnelReqMsg* _internal_mutable_newtunnelreq();
  public:
  void unsafe_arena_set_allocated_newtunnelreq(
      ::NewTunnelReqMsg* newtunnelreq);
  ::NewTunnelReqMsg* unsafe_arena_release_newtunnelreq();

  // optional .NewTunnelRspMsg newTunnelRsp = 5;
  bool has_newtunnelrsp() const;
  private:
  bool _internal_has_newtunnelrsp() const;
  public:
  void clear_newtunnelrsp();
  const ::NewTunnelRspMsg& newtunnelrsp() const;
  PROTOBUF_NODISCARD ::NewTunnelRspMsg* release_newtunnelrsp();
  ::NewTunnelRspMsg* mutable_newtunnelrsp();
  void set_allocated_newtunnelrsp(::NewTunnelRspMsg* newtunnelrsp);
  private:
  const ::NewTunnelRspMsg& _internal_newtunnelrsp() const;
  ::NewTunnelRspMsg* _internal_mutable_newtunnelrsp();
  public:
  void unsafe_arena_set_allocated_newtunnelrsp(
      ::NewTunnelRspMsg* newtunnelrsp);
  ::NewTunnelRspMsg* unsafe_arena_release_newtunnelrsp();

  // optional .FreeProxyConnMsg freeProxyConn = 6;
  bool has_freeproxyconn() const;
  private:
  bool _internal_has_freeproxyconn() const;
  public:
  void clear_freeproxyconn();
  const ::FreeProxyConnMsg& freeproxyconn() const;
  PROTOBUF_NODISCARD ::FreeProxyConnMsg* release_freeproxyconn();
  ::FreeProxyConnMsg* mutable_freeproxyconn();
  void set_allocated_freeproxyconn(::FreeProxyConnMsg* freeproxyconn);
  private:
  const ::FreeProxyConnMsg& _internal_freeproxyconn() const;
  ::FreeProxyConnMsg* _internal_mutable_freeproxyconn();
  public:
  void unsafe_arena_set_allocated_freeproxyconn(
      ::FreeProxyConnMsg* freeproxyconn);
  ::FreeProxyConnMsg* unsafe_arena_release_freeproxyconn();

  // optional .NotifyClientCreateProxyMsg notifyClientCreateProxy = 7;
  bool has_notifyclientcreateproxy() const;
  private:
  bool _internal_has_notifyclientcreateproxy() const;
  public:
  void clear_notifyclientcreateproxy();
  const ::NotifyClientCreateProxyMsg& notifyclientcreateproxy() const;
  PROTOBUF_NODISCARD ::NotifyClientCreateProxyMsg* release_notifyclientcreateproxy();
  ::NotifyClientCreateProxyMsg* mutable_notifyclientcreateproxy();
  void set_allocated_notifyclientcreateproxy(::NotifyClientCreateProxyMsg* notifyclientcreateproxy);
  private:
  const ::NotifyClientCreateProxyMsg& _internal_notifyclientcreateproxy() const;
  ::NotifyClientCreateProxyMsg* _internal_mutable_notifyclientcreateproxy();
  public:
  void unsafe_arena_set_allocated_notifyclientcreateproxy(
      ::NotifyClientCreateProxyMsg* notifyclientcreateproxy);
  ::NotifyClientCreateProxyMsg* unsafe_arena_release_notifyclientcreateproxy();

  // optional .NotifyShutdownProxyMsg notifyShutdownProxy = 8;
  bool has_notifyshutdownproxy() const;
  private:
  bool _internal_has_notifyshutdownproxy() const;
  public:
  void clear_notifyshutdownproxy();
  const ::NotifyShutdownProxyMsg& notifyshutdownproxy() const;
  PROTOBUF_NODISCARD ::NotifyShutdownProxyMsg* release_notifyshutdownproxy();
  ::NotifyShutdownProxyMsg* mutable_notifyshutdownproxy();
  void set_allocated_notifyshutdownproxy(::NotifyShutdownProxyMsg* notifyshutdownproxy);
  private:
  const ::NotifyShutdownProxyMsg& _internal_notifyshutdownproxy() const;
  ::NotifyShutdownProxyMsg* _internal_mutable_notifyshutdownproxy();
  public:
  void unsafe_arena_set_allocated_notifyshutdownproxy(
      ::NotifyShutdownProxyMsg* notifyshutdownproxy);
  ::NotifyShutdownProxyMsg* unsafe_arena_release_notifyshutdownproxy();

  // optional .ClaimProxyConnMsg claimProxyConn = 9;
  bool has_claimproxyconn() const;
  private:
  bool _internal_has_claimproxyconn() const;
  public:
  void clear_claimproxyconn();
  const ::ClaimProxyConnMsg& claimproxyconn() const;
  PROTOBUF_NODISCARD ::ClaimProxyConnMsg* release_claimproxyconn();
  ::ClaimProxyConnMsg* mutable_claimproxyconn();
  void set_allocated_claimproxyconn(::ClaimProxyConnMsg* claimproxyconn);
  private:
  const ::ClaimProxyConnMsg& _internal_claimproxyconn() const;
  ::ClaimProxyConnMsg* _internal_mutable_claimproxyconn();
  public:
  void unsafe_arena_set_allocated_claimproxyconn(
      ::ClaimProxyConnMsg* claimproxyconn);
  ::ClaimProxyConnMsg* unsafe_arena_release_claimproxyconn();

  // optional .StartProxyReqMsg startProxyReq = 10;
  bool has_startproxyreq() const;
  private:
  bool _internal_has_startproxyreq() const;
  public:
  void clear_startproxyreq();
  const ::StartProxyReqMsg& startproxyreq() const;
  PROTOBUF_NODISCARD ::StartProxyReqMsg* release_startproxyreq();
  ::StartProxyReqMsg* mutable_startproxyreq();
  void set_allocated_startproxyreq(::StartProxyReqMsg* startproxyreq);
  private:
  const ::StartProxyReqMsg& _internal_startproxyreq() const;
  ::StartProxyReqMsg* _internal_mutable_startproxyreq();
  public:
  void unsafe_arena_set_allocated_startproxyreq(
      ::StartProxyReqMsg* startproxyreq);
  ::StartProxyReqMsg* unsafe_arena_release_startproxyreq();

  // optional .StartProxyRspMsg startProxyRsp = 11;
  bool has_startproxyrsp() const;
  private:
  bool _internal_has_startproxyrsp() const;
  public:
  void clear_startproxyrsp();
  const ::StartProxyRspMsg& startproxyrsp() const;
  PROTOBUF_NODISCARD ::StartProxyRspMsg* release_startproxyrsp();
  ::StartProxyRspMsg* mutable_startproxyrsp();
  void set_allocated_startproxyrsp(::StartProxyRspMsg* startproxyrsp);
  private:
  const ::StartProxyRspMsg& _internal_startproxyrsp() const;
  ::StartProxyRspMsg* _internal_mutable_startproxyrsp();
  public:
  void unsafe_arena_set_allocated_startproxyrsp(
      ::StartProxyRspMsg* startproxyrsp);
  ::StartProxyRspMsg* unsafe_arena_release_startproxyrsp();

  // .MessageType messageType = 1;
  void clear_messagetype();
  ::MessageType messagetype() const;
  void set_messagetype(::MessageType value);
  private:
  ::MessageType _internal_messagetype() const;
  void _internal_set_messagetype(::MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:NetMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::NewCtlReqMsg* newctlreq_;
    ::NewCtlRspMsg* newctlrsp_;
    ::NewTunnelReqMsg* newtunnelreq_;
    ::NewTunnelRspMsg* newtunnelrsp_;
    ::FreeProxyConnMsg* freeproxyconn_;
    ::NotifyClientCreateProxyMsg* notifyclientcreateproxy_;
    ::NotifyShutdownProxyMsg* notifyshutdownproxy_;
    ::ClaimProxyConnMsg* claimproxyconn_;
    ::StartProxyReqMsg* startproxyreq_;
    ::StartProxyRspMsg* startproxyrsp_;
    int messagetype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Proxy_2eproto;
};
// -------------------------------------------------------------------

class NewCtlReqMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:NewCtlReqMsg) */ {
 public:
  inline NewCtlReqMsg() : NewCtlReqMsg(nullptr) {}
  explicit PROTOBUF_CONSTEXPR NewCtlReqMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewCtlReqMsg(const NewCtlReqMsg& from);
  NewCtlReqMsg(NewCtlReqMsg&& from) noexcept
    : NewCtlReqMsg() {
    *this = ::std::move(from);
  }

  inline NewCtlReqMsg& operator=(const NewCtlReqMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewCtlReqMsg& operator=(NewCtlReqMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewCtlReqMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewCtlReqMsg* internal_default_instance() {
    return reinterpret_cast<const NewCtlReqMsg*>(
               &_NewCtlReqMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NewCtlReqMsg& a, NewCtlReqMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(NewCtlReqMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewCtlReqMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewCtlReqMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewCtlReqMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NewCtlReqMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NewCtlReqMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NewCtlReqMsg";
  }
  protected:
  explicit NewCtlReqMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:NewCtlReqMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Proxy_2eproto;
};
// -------------------------------------------------------------------

class NewCtlRspMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NewCtlRspMsg) */ {
 public:
  inline NewCtlRspMsg() : NewCtlRspMsg(nullptr) {}
  ~NewCtlRspMsg() override;
  explicit PROTOBUF_CONSTEXPR NewCtlRspMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewCtlRspMsg(const NewCtlRspMsg& from);
  NewCtlRspMsg(NewCtlRspMsg&& from) noexcept
    : NewCtlRspMsg() {
    *this = ::std::move(from);
  }

  inline NewCtlRspMsg& operator=(const NewCtlRspMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewCtlRspMsg& operator=(NewCtlRspMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewCtlRspMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewCtlRspMsg* internal_default_instance() {
    return reinterpret_cast<const NewCtlRspMsg*>(
               &_NewCtlRspMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NewCtlRspMsg& a, NewCtlRspMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(NewCtlRspMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewCtlRspMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewCtlRspMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewCtlRspMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewCtlRspMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewCtlRspMsg& from) {
    NewCtlRspMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewCtlRspMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NewCtlRspMsg";
  }
  protected:
  explicit NewCtlRspMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtlIdFieldNumber = 1,
  };
  // string ctl_id = 1;
  void clear_ctl_id();
  const std::string& ctl_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ctl_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ctl_id();
  PROTOBUF_NODISCARD std::string* release_ctl_id();
  void set_allocated_ctl_id(std::string* ctl_id);
  private:
  const std::string& _internal_ctl_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ctl_id(const std::string& value);
  std::string* _internal_mutable_ctl_id();
  public:

  // @@protoc_insertion_point(class_scope:NewCtlRspMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ctl_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Proxy_2eproto;
};
// -------------------------------------------------------------------

class NewTunnelReqMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NewTunnelReqMsg) */ {
 public:
  inline NewTunnelReqMsg() : NewTunnelReqMsg(nullptr) {}
  ~NewTunnelReqMsg() override;
  explicit PROTOBUF_CONSTEXPR NewTunnelReqMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewTunnelReqMsg(const NewTunnelReqMsg& from);
  NewTunnelReqMsg(NewTunnelReqMsg&& from) noexcept
    : NewTunnelReqMsg() {
    *this = ::std::move(from);
  }

  inline NewTunnelReqMsg& operator=(const NewTunnelReqMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewTunnelReqMsg& operator=(NewTunnelReqMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewTunnelReqMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewTunnelReqMsg* internal_default_instance() {
    return reinterpret_cast<const NewTunnelReqMsg*>(
               &_NewTunnelReqMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NewTunnelReqMsg& a, NewTunnelReqMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(NewTunnelReqMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewTunnelReqMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewTunnelReqMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewTunnelReqMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewTunnelReqMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewTunnelReqMsg& from) {
    NewTunnelReqMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewTunnelReqMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NewTunnelReqMsg";
  }
  protected:
  explicit NewTunnelReqMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalServerHostFieldNumber = 1,
    kLocalServerPortFieldNumber = 2,
  };
  // string local_server_host = 1;
  void clear_local_server_host();
  const std::string& local_server_host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_server_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_server_host();
  PROTOBUF_NODISCARD std::string* release_local_server_host();
  void set_allocated_local_server_host(std::string* local_server_host);
  private:
  const std::string& _internal_local_server_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_server_host(const std::string& value);
  std::string* _internal_mutable_local_server_host();
  public:

  // int32 local_server_port = 2;
  void clear_local_server_port();
  int32_t local_server_port() const;
  void set_local_server_port(int32_t value);
  private:
  int32_t _internal_local_server_port() const;
  void _internal_set_local_server_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NewTunnelReqMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_server_host_;
    int32_t local_server_port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Proxy_2eproto;
};
// -------------------------------------------------------------------

class NewTunnelRspMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NewTunnelRspMsg) */ {
 public:
  inline NewTunnelRspMsg() : NewTunnelRspMsg(nullptr) {}
  ~NewTunnelRspMsg() override;
  explicit PROTOBUF_CONSTEXPR NewTunnelRspMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewTunnelRspMsg(const NewTunnelRspMsg& from);
  NewTunnelRspMsg(NewTunnelRspMsg&& from) noexcept
    : NewTunnelRspMsg() {
    *this = ::std::move(from);
  }

  inline NewTunnelRspMsg& operator=(const NewTunnelRspMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewTunnelRspMsg& operator=(NewTunnelRspMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewTunnelRspMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewTunnelRspMsg* internal_default_instance() {
    return reinterpret_cast<const NewTunnelRspMsg*>(
               &_NewTunnelRspMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NewTunnelRspMsg& a, NewTunnelRspMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(NewTunnelRspMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewTunnelRspMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewTunnelRspMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewTunnelRspMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewTunnelRspMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewTunnelRspMsg& from) {
    NewTunnelRspMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewTunnelRspMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NewTunnelRspMsg";
  }
  protected:
  explicit NewTunnelRspMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTunIdFieldNumber = 1,
    kLocalServerHostFieldNumber = 2,
    kProxyServerHostFieldNumber = 4,
    kLocalServerPortFieldNumber = 3,
    kProxyServerPortFieldNumber = 5,
  };
  // string tun_id = 1;
  void clear_tun_id();
  const std::string& tun_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tun_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tun_id();
  PROTOBUF_NODISCARD std::string* release_tun_id();
  void set_allocated_tun_id(std::string* tun_id);
  private:
  const std::string& _internal_tun_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tun_id(const std::string& value);
  std::string* _internal_mutable_tun_id();
  public:

  // string local_server_host = 2;
  void clear_local_server_host();
  const std::string& local_server_host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_server_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_server_host();
  PROTOBUF_NODISCARD std::string* release_local_server_host();
  void set_allocated_local_server_host(std::string* local_server_host);
  private:
  const std::string& _internal_local_server_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_server_host(const std::string& value);
  std::string* _internal_mutable_local_server_host();
  public:

  // string proxy_server_host = 4;
  void clear_proxy_server_host();
  const std::string& proxy_server_host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proxy_server_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proxy_server_host();
  PROTOBUF_NODISCARD std::string* release_proxy_server_host();
  void set_allocated_proxy_server_host(std::string* proxy_server_host);
  private:
  const std::string& _internal_proxy_server_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proxy_server_host(const std::string& value);
  std::string* _internal_mutable_proxy_server_host();
  public:

  // int32 local_server_port = 3;
  void clear_local_server_port();
  int32_t local_server_port() const;
  void set_local_server_port(int32_t value);
  private:
  int32_t _internal_local_server_port() const;
  void _internal_set_local_server_port(int32_t value);
  public:

  // int32 proxy_server_port = 5;
  void clear_proxy_server_port();
  int32_t proxy_server_port() const;
  void set_proxy_server_port(int32_t value);
  private:
  int32_t _internal_proxy_server_port() const;
  void _internal_set_proxy_server_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NewTunnelRspMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tun_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_server_host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proxy_server_host_;
    int32_t local_server_port_;
    int32_t proxy_server_port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Proxy_2eproto;
};
// -------------------------------------------------------------------

class FreeProxyConnMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FreeProxyConnMsg) */ {
 public:
  inline FreeProxyConnMsg() : FreeProxyConnMsg(nullptr) {}
  ~FreeProxyConnMsg() override;
  explicit PROTOBUF_CONSTEXPR FreeProxyConnMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreeProxyConnMsg(const FreeProxyConnMsg& from);
  FreeProxyConnMsg(FreeProxyConnMsg&& from) noexcept
    : FreeProxyConnMsg() {
    *this = ::std::move(from);
  }

  inline FreeProxyConnMsg& operator=(const FreeProxyConnMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreeProxyConnMsg& operator=(FreeProxyConnMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreeProxyConnMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreeProxyConnMsg* internal_default_instance() {
    return reinterpret_cast<const FreeProxyConnMsg*>(
               &_FreeProxyConnMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FreeProxyConnMsg& a, FreeProxyConnMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(FreeProxyConnMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreeProxyConnMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FreeProxyConnMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FreeProxyConnMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FreeProxyConnMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FreeProxyConnMsg& from) {
    FreeProxyConnMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreeProxyConnMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FreeProxyConnMsg";
  }
  protected:
  explicit FreeProxyConnMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTunIdFieldNumber = 1,
    kTConnIdFieldNumber = 2,
  };
  // string tun_id = 1;
  void clear_tun_id();
  const std::string& tun_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tun_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tun_id();
  PROTOBUF_NODISCARD std::string* release_tun_id();
  void set_allocated_tun_id(std::string* tun_id);
  private:
  const std::string& _internal_tun_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tun_id(const std::string& value);
  std::string* _internal_mutable_tun_id();
  public:

  // string TConn_id = 2;
  void clear_tconn_id();
  const std::string& tconn_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tconn_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tconn_id();
  PROTOBUF_NODISCARD std::string* release_tconn_id();
  void set_allocated_tconn_id(std::string* tconn_id);
  private:
  const std::string& _internal_tconn_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tconn_id(const std::string& value);
  std::string* _internal_mutable_tconn_id();
  public:

  // @@protoc_insertion_point(class_scope:FreeProxyConnMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tun_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tconn_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Proxy_2eproto;
};
// -------------------------------------------------------------------

class NotifyClientCreateProxyMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NotifyClientCreateProxyMsg) */ {
 public:
  inline NotifyClientCreateProxyMsg() : NotifyClientCreateProxyMsg(nullptr) {}
  ~NotifyClientCreateProxyMsg() override;
  explicit PROTOBUF_CONSTEXPR NotifyClientCreateProxyMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyClientCreateProxyMsg(const NotifyClientCreateProxyMsg& from);
  NotifyClientCreateProxyMsg(NotifyClientCreateProxyMsg&& from) noexcept
    : NotifyClientCreateProxyMsg() {
    *this = ::std::move(from);
  }

  inline NotifyClientCreateProxyMsg& operator=(const NotifyClientCreateProxyMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyClientCreateProxyMsg& operator=(NotifyClientCreateProxyMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyClientCreateProxyMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyClientCreateProxyMsg* internal_default_instance() {
    return reinterpret_cast<const NotifyClientCreateProxyMsg*>(
               &_NotifyClientCreateProxyMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NotifyClientCreateProxyMsg& a, NotifyClientCreateProxyMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyClientCreateProxyMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyClientCreateProxyMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyClientCreateProxyMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyClientCreateProxyMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyClientCreateProxyMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyClientCreateProxyMsg& from) {
    NotifyClientCreateProxyMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyClientCreateProxyMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NotifyClientCreateProxyMsg";
  }
  protected:
  explicit NotifyClientCreateProxyMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTunIdFieldNumber = 1,
    kServerProxyPortFieldNumber = 2,
  };
  // string Tun_id = 1;
  void clear_tun_id();
  const std::string& tun_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tun_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tun_id();
  PROTOBUF_NODISCARD std::string* release_tun_id();
  void set_allocated_tun_id(std::string* tun_id);
  private:
  const std::string& _internal_tun_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tun_id(const std::string& value);
  std::string* _internal_mutable_tun_id();
  public:

  // int32 server_proxy_port = 2;
  void clear_server_proxy_port();
  int32_t server_proxy_port() const;
  void set_server_proxy_port(int32_t value);
  private:
  int32_t _internal_server_proxy_port() const;
  void _internal_set_server_proxy_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NotifyClientCreateProxyMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tun_id_;
    int32_t server_proxy_port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Proxy_2eproto;
};
// -------------------------------------------------------------------

class NotifyShutdownProxyMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NotifyShutdownProxyMsg) */ {
 public:
  inline NotifyShutdownProxyMsg() : NotifyShutdownProxyMsg(nullptr) {}
  ~NotifyShutdownProxyMsg() override;
  explicit PROTOBUF_CONSTEXPR NotifyShutdownProxyMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyShutdownProxyMsg(const NotifyShutdownProxyMsg& from);
  NotifyShutdownProxyMsg(NotifyShutdownProxyMsg&& from) noexcept
    : NotifyShutdownProxyMsg() {
    *this = ::std::move(from);
  }

  inline NotifyShutdownProxyMsg& operator=(const NotifyShutdownProxyMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyShutdownProxyMsg& operator=(NotifyShutdownProxyMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyShutdownProxyMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyShutdownProxyMsg* internal_default_instance() {
    return reinterpret_cast<const NotifyShutdownProxyMsg*>(
               &_NotifyShutdownProxyMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NotifyShutdownProxyMsg& a, NotifyShutdownProxyMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyShutdownProxyMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyShutdownProxyMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyShutdownProxyMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyShutdownProxyMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyShutdownProxyMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyShutdownProxyMsg& from) {
    NotifyShutdownProxyMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyShutdownProxyMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NotifyShutdownProxyMsg";
  }
  protected:
  explicit NotifyShutdownProxyMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTunIdFieldNumber = 1,
    kTConnIdFieldNumber = 2,
    kTranCountFieldNumber = 3,
  };
  // string Tun_id = 1;
  void clear_tun_id();
  const std::string& tun_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tun_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tun_id();
  PROTOBUF_NODISCARD std::string* release_tun_id();
  void set_allocated_tun_id(std::string* tun_id);
  private:
  const std::string& _internal_tun_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tun_id(const std::string& value);
  std::string* _internal_mutable_tun_id();
  public:

  // string TConn_id = 2;
  void clear_tconn_id();
  const std::string& tconn_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tconn_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tconn_id();
  PROTOBUF_NODISCARD std::string* release_tconn_id();
  void set_allocated_tconn_id(std::string* tconn_id);
  private:
  const std::string& _internal_tconn_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tconn_id(const std::string& value);
  std::string* _internal_mutable_tconn_id();
  public:

  // int32 tran_count = 3;
  void clear_tran_count();
  int32_t tran_count() const;
  void set_tran_count(int32_t value);
  private:
  int32_t _internal_tran_count() const;
  void _internal_set_tran_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NotifyShutdownProxyMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tun_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tconn_id_;
    int32_t tran_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Proxy_2eproto;
};
// -------------------------------------------------------------------

class ClaimProxyConnMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClaimProxyConnMsg) */ {
 public:
  inline ClaimProxyConnMsg() : ClaimProxyConnMsg(nullptr) {}
  ~ClaimProxyConnMsg() override;
  explicit PROTOBUF_CONSTEXPR ClaimProxyConnMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClaimProxyConnMsg(const ClaimProxyConnMsg& from);
  ClaimProxyConnMsg(ClaimProxyConnMsg&& from) noexcept
    : ClaimProxyConnMsg() {
    *this = ::std::move(from);
  }

  inline ClaimProxyConnMsg& operator=(const ClaimProxyConnMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClaimProxyConnMsg& operator=(ClaimProxyConnMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClaimProxyConnMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClaimProxyConnMsg* internal_default_instance() {
    return reinterpret_cast<const ClaimProxyConnMsg*>(
               &_ClaimProxyConnMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ClaimProxyConnMsg& a, ClaimProxyConnMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ClaimProxyConnMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClaimProxyConnMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClaimProxyConnMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClaimProxyConnMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClaimProxyConnMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClaimProxyConnMsg& from) {
    ClaimProxyConnMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClaimProxyConnMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClaimProxyConnMsg";
  }
  protected:
  explicit ClaimProxyConnMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtlIdFieldNumber = 1,
    kTunIdFieldNumber = 2,
    kTConnIdFieldNumber = 3,
  };
  // string ctl_id = 1;
  void clear_ctl_id();
  const std::string& ctl_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ctl_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ctl_id();
  PROTOBUF_NODISCARD std::string* release_ctl_id();
  void set_allocated_ctl_id(std::string* ctl_id);
  private:
  const std::string& _internal_ctl_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ctl_id(const std::string& value);
  std::string* _internal_mutable_ctl_id();
  public:

  // string tun_id = 2;
  void clear_tun_id();
  const std::string& tun_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tun_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tun_id();
  PROTOBUF_NODISCARD std::string* release_tun_id();
  void set_allocated_tun_id(std::string* tun_id);
  private:
  const std::string& _internal_tun_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tun_id(const std::string& value);
  std::string* _internal_mutable_tun_id();
  public:

  // string TConn_id = 3;
  void clear_tconn_id();
  const std::string& tconn_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tconn_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tconn_id();
  PROTOBUF_NODISCARD std::string* release_tconn_id();
  void set_allocated_tconn_id(std::string* tconn_id);
  private:
  const std::string& _internal_tconn_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tconn_id(const std::string& value);
  std::string* _internal_mutable_tconn_id();
  public:

  // @@protoc_insertion_point(class_scope:ClaimProxyConnMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ctl_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tun_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tconn_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Proxy_2eproto;
};
// -------------------------------------------------------------------

class StartProxyReqMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StartProxyReqMsg) */ {
 public:
  inline StartProxyReqMsg() : StartProxyReqMsg(nullptr) {}
  ~StartProxyReqMsg() override;
  explicit PROTOBUF_CONSTEXPR StartProxyReqMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartProxyReqMsg(const StartProxyReqMsg& from);
  StartProxyReqMsg(StartProxyReqMsg&& from) noexcept
    : StartProxyReqMsg() {
    *this = ::std::move(from);
  }

  inline StartProxyReqMsg& operator=(const StartProxyReqMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartProxyReqMsg& operator=(StartProxyReqMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartProxyReqMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartProxyReqMsg* internal_default_instance() {
    return reinterpret_cast<const StartProxyReqMsg*>(
               &_StartProxyReqMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StartProxyReqMsg& a, StartProxyReqMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(StartProxyReqMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartProxyReqMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartProxyReqMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartProxyReqMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartProxyReqMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartProxyReqMsg& from) {
    StartProxyReqMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartProxyReqMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StartProxyReqMsg";
  }
  protected:
  explicit StartProxyReqMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTConnIdFieldNumber = 1,
    kPublicWaitConnidFieldNumber = 2,
  };
  // string TConn_id = 1;
  void clear_tconn_id();
  const std::string& tconn_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tconn_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tconn_id();
  PROTOBUF_NODISCARD std::string* release_tconn_id();
  void set_allocated_tconn_id(std::string* tconn_id);
  private:
  const std::string& _internal_tconn_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tconn_id(const std::string& value);
  std::string* _internal_mutable_tconn_id();
  public:

  // string PublicWaitConnid = 2;
  void clear_publicwaitconnid();
  const std::string& publicwaitconnid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publicwaitconnid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publicwaitconnid();
  PROTOBUF_NODISCARD std::string* release_publicwaitconnid();
  void set_allocated_publicwaitconnid(std::string* publicwaitconnid);
  private:
  const std::string& _internal_publicwaitconnid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publicwaitconnid(const std::string& value);
  std::string* _internal_mutable_publicwaitconnid();
  public:

  // @@protoc_insertion_point(class_scope:StartProxyReqMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tconn_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publicwaitconnid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Proxy_2eproto;
};
// -------------------------------------------------------------------

class StartProxyRspMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StartProxyRspMsg) */ {
 public:
  inline StartProxyRspMsg() : StartProxyRspMsg(nullptr) {}
  ~StartProxyRspMsg() override;
  explicit PROTOBUF_CONSTEXPR StartProxyRspMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartProxyRspMsg(const StartProxyRspMsg& from);
  StartProxyRspMsg(StartProxyRspMsg&& from) noexcept
    : StartProxyRspMsg() {
    *this = ::std::move(from);
  }

  inline StartProxyRspMsg& operator=(const StartProxyRspMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartProxyRspMsg& operator=(StartProxyRspMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartProxyRspMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartProxyRspMsg* internal_default_instance() {
    return reinterpret_cast<const StartProxyRspMsg*>(
               &_StartProxyRspMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StartProxyRspMsg& a, StartProxyRspMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(StartProxyRspMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartProxyRspMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartProxyRspMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartProxyRspMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartProxyRspMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartProxyRspMsg& from) {
    StartProxyRspMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartProxyRspMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StartProxyRspMsg";
  }
  protected:
  explicit StartProxyRspMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicWaitConnidFieldNumber = 1,
  };
  // string PublicWaitConnid = 1;
  void clear_publicwaitconnid();
  const std::string& publicwaitconnid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publicwaitconnid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publicwaitconnid();
  PROTOBUF_NODISCARD std::string* release_publicwaitconnid();
  void set_allocated_publicwaitconnid(std::string* publicwaitconnid);
  private:
  const std::string& _internal_publicwaitconnid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publicwaitconnid(const std::string& value);
  std::string* _internal_mutable_publicwaitconnid();
  public:

  // @@protoc_insertion_point(class_scope:StartProxyRspMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publicwaitconnid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Proxy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NetMsg

// .MessageType messageType = 1;
inline void NetMsg::clear_messagetype() {
  _impl_.messagetype_ = 0;
}
inline ::MessageType NetMsg::_internal_messagetype() const {
  return static_cast< ::MessageType >(_impl_.messagetype_);
}
inline ::MessageType NetMsg::messagetype() const {
  // @@protoc_insertion_point(field_get:NetMsg.messageType)
  return _internal_messagetype();
}
inline void NetMsg::_internal_set_messagetype(::MessageType value) {
  
  _impl_.messagetype_ = value;
}
inline void NetMsg::set_messagetype(::MessageType value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:NetMsg.messageType)
}

// optional .NewCtlReqMsg newCtlReq = 2;
inline bool NetMsg::_internal_has_newctlreq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.newctlreq_ != nullptr);
  return value;
}
inline bool NetMsg::has_newctlreq() const {
  return _internal_has_newctlreq();
}
inline void NetMsg::clear_newctlreq() {
  if (_impl_.newctlreq_ != nullptr) _impl_.newctlreq_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::NewCtlReqMsg& NetMsg::_internal_newctlreq() const {
  const ::NewCtlReqMsg* p = _impl_.newctlreq_;
  return p != nullptr ? *p : reinterpret_cast<const ::NewCtlReqMsg&>(
      ::_NewCtlReqMsg_default_instance_);
}
inline const ::NewCtlReqMsg& NetMsg::newctlreq() const {
  // @@protoc_insertion_point(field_get:NetMsg.newCtlReq)
  return _internal_newctlreq();
}
inline void NetMsg::unsafe_arena_set_allocated_newctlreq(
    ::NewCtlReqMsg* newctlreq) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newctlreq_);
  }
  _impl_.newctlreq_ = newctlreq;
  if (newctlreq) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NetMsg.newCtlReq)
}
inline ::NewCtlReqMsg* NetMsg::release_newctlreq() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NewCtlReqMsg* temp = _impl_.newctlreq_;
  _impl_.newctlreq_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NewCtlReqMsg* NetMsg::unsafe_arena_release_newctlreq() {
  // @@protoc_insertion_point(field_release:NetMsg.newCtlReq)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::NewCtlReqMsg* temp = _impl_.newctlreq_;
  _impl_.newctlreq_ = nullptr;
  return temp;
}
inline ::NewCtlReqMsg* NetMsg::_internal_mutable_newctlreq() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.newctlreq_ == nullptr) {
    auto* p = CreateMaybeMessage<::NewCtlReqMsg>(GetArenaForAllocation());
    _impl_.newctlreq_ = p;
  }
  return _impl_.newctlreq_;
}
inline ::NewCtlReqMsg* NetMsg::mutable_newctlreq() {
  ::NewCtlReqMsg* _msg = _internal_mutable_newctlreq();
  // @@protoc_insertion_point(field_mutable:NetMsg.newCtlReq)
  return _msg;
}
inline void NetMsg::set_allocated_newctlreq(::NewCtlReqMsg* newctlreq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.newctlreq_;
  }
  if (newctlreq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(newctlreq);
    if (message_arena != submessage_arena) {
      newctlreq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newctlreq, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.newctlreq_ = newctlreq;
  // @@protoc_insertion_point(field_set_allocated:NetMsg.newCtlReq)
}

// optional .NewCtlRspMsg newCtlRsp = 3;
inline bool NetMsg::_internal_has_newctlrsp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.newctlrsp_ != nullptr);
  return value;
}
inline bool NetMsg::has_newctlrsp() const {
  return _internal_has_newctlrsp();
}
inline void NetMsg::clear_newctlrsp() {
  if (_impl_.newctlrsp_ != nullptr) _impl_.newctlrsp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::NewCtlRspMsg& NetMsg::_internal_newctlrsp() const {
  const ::NewCtlRspMsg* p = _impl_.newctlrsp_;
  return p != nullptr ? *p : reinterpret_cast<const ::NewCtlRspMsg&>(
      ::_NewCtlRspMsg_default_instance_);
}
inline const ::NewCtlRspMsg& NetMsg::newctlrsp() const {
  // @@protoc_insertion_point(field_get:NetMsg.newCtlRsp)
  return _internal_newctlrsp();
}
inline void NetMsg::unsafe_arena_set_allocated_newctlrsp(
    ::NewCtlRspMsg* newctlrsp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newctlrsp_);
  }
  _impl_.newctlrsp_ = newctlrsp;
  if (newctlrsp) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NetMsg.newCtlRsp)
}
inline ::NewCtlRspMsg* NetMsg::release_newctlrsp() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NewCtlRspMsg* temp = _impl_.newctlrsp_;
  _impl_.newctlrsp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NewCtlRspMsg* NetMsg::unsafe_arena_release_newctlrsp() {
  // @@protoc_insertion_point(field_release:NetMsg.newCtlRsp)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::NewCtlRspMsg* temp = _impl_.newctlrsp_;
  _impl_.newctlrsp_ = nullptr;
  return temp;
}
inline ::NewCtlRspMsg* NetMsg::_internal_mutable_newctlrsp() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.newctlrsp_ == nullptr) {
    auto* p = CreateMaybeMessage<::NewCtlRspMsg>(GetArenaForAllocation());
    _impl_.newctlrsp_ = p;
  }
  return _impl_.newctlrsp_;
}
inline ::NewCtlRspMsg* NetMsg::mutable_newctlrsp() {
  ::NewCtlRspMsg* _msg = _internal_mutable_newctlrsp();
  // @@protoc_insertion_point(field_mutable:NetMsg.newCtlRsp)
  return _msg;
}
inline void NetMsg::set_allocated_newctlrsp(::NewCtlRspMsg* newctlrsp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.newctlrsp_;
  }
  if (newctlrsp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(newctlrsp);
    if (message_arena != submessage_arena) {
      newctlrsp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newctlrsp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.newctlrsp_ = newctlrsp;
  // @@protoc_insertion_point(field_set_allocated:NetMsg.newCtlRsp)
}

// optional .NewTunnelReqMsg newTunnelReq = 4;
inline bool NetMsg::_internal_has_newtunnelreq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.newtunnelreq_ != nullptr);
  return value;
}
inline bool NetMsg::has_newtunnelreq() const {
  return _internal_has_newtunnelreq();
}
inline void NetMsg::clear_newtunnelreq() {
  if (_impl_.newtunnelreq_ != nullptr) _impl_.newtunnelreq_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::NewTunnelReqMsg& NetMsg::_internal_newtunnelreq() const {
  const ::NewTunnelReqMsg* p = _impl_.newtunnelreq_;
  return p != nullptr ? *p : reinterpret_cast<const ::NewTunnelReqMsg&>(
      ::_NewTunnelReqMsg_default_instance_);
}
inline const ::NewTunnelReqMsg& NetMsg::newtunnelreq() const {
  // @@protoc_insertion_point(field_get:NetMsg.newTunnelReq)
  return _internal_newtunnelreq();
}
inline void NetMsg::unsafe_arena_set_allocated_newtunnelreq(
    ::NewTunnelReqMsg* newtunnelreq) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newtunnelreq_);
  }
  _impl_.newtunnelreq_ = newtunnelreq;
  if (newtunnelreq) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NetMsg.newTunnelReq)
}
inline ::NewTunnelReqMsg* NetMsg::release_newtunnelreq() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::NewTunnelReqMsg* temp = _impl_.newtunnelreq_;
  _impl_.newtunnelreq_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NewTunnelReqMsg* NetMsg::unsafe_arena_release_newtunnelreq() {
  // @@protoc_insertion_point(field_release:NetMsg.newTunnelReq)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::NewTunnelReqMsg* temp = _impl_.newtunnelreq_;
  _impl_.newtunnelreq_ = nullptr;
  return temp;
}
inline ::NewTunnelReqMsg* NetMsg::_internal_mutable_newtunnelreq() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.newtunnelreq_ == nullptr) {
    auto* p = CreateMaybeMessage<::NewTunnelReqMsg>(GetArenaForAllocation());
    _impl_.newtunnelreq_ = p;
  }
  return _impl_.newtunnelreq_;
}
inline ::NewTunnelReqMsg* NetMsg::mutable_newtunnelreq() {
  ::NewTunnelReqMsg* _msg = _internal_mutable_newtunnelreq();
  // @@protoc_insertion_point(field_mutable:NetMsg.newTunnelReq)
  return _msg;
}
inline void NetMsg::set_allocated_newtunnelreq(::NewTunnelReqMsg* newtunnelreq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.newtunnelreq_;
  }
  if (newtunnelreq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(newtunnelreq);
    if (message_arena != submessage_arena) {
      newtunnelreq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newtunnelreq, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.newtunnelreq_ = newtunnelreq;
  // @@protoc_insertion_point(field_set_allocated:NetMsg.newTunnelReq)
}

// optional .NewTunnelRspMsg newTunnelRsp = 5;
inline bool NetMsg::_internal_has_newtunnelrsp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.newtunnelrsp_ != nullptr);
  return value;
}
inline bool NetMsg::has_newtunnelrsp() const {
  return _internal_has_newtunnelrsp();
}
inline void NetMsg::clear_newtunnelrsp() {
  if (_impl_.newtunnelrsp_ != nullptr) _impl_.newtunnelrsp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::NewTunnelRspMsg& NetMsg::_internal_newtunnelrsp() const {
  const ::NewTunnelRspMsg* p = _impl_.newtunnelrsp_;
  return p != nullptr ? *p : reinterpret_cast<const ::NewTunnelRspMsg&>(
      ::_NewTunnelRspMsg_default_instance_);
}
inline const ::NewTunnelRspMsg& NetMsg::newtunnelrsp() const {
  // @@protoc_insertion_point(field_get:NetMsg.newTunnelRsp)
  return _internal_newtunnelrsp();
}
inline void NetMsg::unsafe_arena_set_allocated_newtunnelrsp(
    ::NewTunnelRspMsg* newtunnelrsp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newtunnelrsp_);
  }
  _impl_.newtunnelrsp_ = newtunnelrsp;
  if (newtunnelrsp) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NetMsg.newTunnelRsp)
}
inline ::NewTunnelRspMsg* NetMsg::release_newtunnelrsp() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::NewTunnelRspMsg* temp = _impl_.newtunnelrsp_;
  _impl_.newtunnelrsp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NewTunnelRspMsg* NetMsg::unsafe_arena_release_newtunnelrsp() {
  // @@protoc_insertion_point(field_release:NetMsg.newTunnelRsp)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::NewTunnelRspMsg* temp = _impl_.newtunnelrsp_;
  _impl_.newtunnelrsp_ = nullptr;
  return temp;
}
inline ::NewTunnelRspMsg* NetMsg::_internal_mutable_newtunnelrsp() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.newtunnelrsp_ == nullptr) {
    auto* p = CreateMaybeMessage<::NewTunnelRspMsg>(GetArenaForAllocation());
    _impl_.newtunnelrsp_ = p;
  }
  return _impl_.newtunnelrsp_;
}
inline ::NewTunnelRspMsg* NetMsg::mutable_newtunnelrsp() {
  ::NewTunnelRspMsg* _msg = _internal_mutable_newtunnelrsp();
  // @@protoc_insertion_point(field_mutable:NetMsg.newTunnelRsp)
  return _msg;
}
inline void NetMsg::set_allocated_newtunnelrsp(::NewTunnelRspMsg* newtunnelrsp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.newtunnelrsp_;
  }
  if (newtunnelrsp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(newtunnelrsp);
    if (message_arena != submessage_arena) {
      newtunnelrsp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newtunnelrsp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.newtunnelrsp_ = newtunnelrsp;
  // @@protoc_insertion_point(field_set_allocated:NetMsg.newTunnelRsp)
}

// optional .FreeProxyConnMsg freeProxyConn = 6;
inline bool NetMsg::_internal_has_freeproxyconn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.freeproxyconn_ != nullptr);
  return value;
}
inline bool NetMsg::has_freeproxyconn() const {
  return _internal_has_freeproxyconn();
}
inline void NetMsg::clear_freeproxyconn() {
  if (_impl_.freeproxyconn_ != nullptr) _impl_.freeproxyconn_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::FreeProxyConnMsg& NetMsg::_internal_freeproxyconn() const {
  const ::FreeProxyConnMsg* p = _impl_.freeproxyconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::FreeProxyConnMsg&>(
      ::_FreeProxyConnMsg_default_instance_);
}
inline const ::FreeProxyConnMsg& NetMsg::freeproxyconn() const {
  // @@protoc_insertion_point(field_get:NetMsg.freeProxyConn)
  return _internal_freeproxyconn();
}
inline void NetMsg::unsafe_arena_set_allocated_freeproxyconn(
    ::FreeProxyConnMsg* freeproxyconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.freeproxyconn_);
  }
  _impl_.freeproxyconn_ = freeproxyconn;
  if (freeproxyconn) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NetMsg.freeProxyConn)
}
inline ::FreeProxyConnMsg* NetMsg::release_freeproxyconn() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::FreeProxyConnMsg* temp = _impl_.freeproxyconn_;
  _impl_.freeproxyconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FreeProxyConnMsg* NetMsg::unsafe_arena_release_freeproxyconn() {
  // @@protoc_insertion_point(field_release:NetMsg.freeProxyConn)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::FreeProxyConnMsg* temp = _impl_.freeproxyconn_;
  _impl_.freeproxyconn_ = nullptr;
  return temp;
}
inline ::FreeProxyConnMsg* NetMsg::_internal_mutable_freeproxyconn() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.freeproxyconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::FreeProxyConnMsg>(GetArenaForAllocation());
    _impl_.freeproxyconn_ = p;
  }
  return _impl_.freeproxyconn_;
}
inline ::FreeProxyConnMsg* NetMsg::mutable_freeproxyconn() {
  ::FreeProxyConnMsg* _msg = _internal_mutable_freeproxyconn();
  // @@protoc_insertion_point(field_mutable:NetMsg.freeProxyConn)
  return _msg;
}
inline void NetMsg::set_allocated_freeproxyconn(::FreeProxyConnMsg* freeproxyconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.freeproxyconn_;
  }
  if (freeproxyconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(freeproxyconn);
    if (message_arena != submessage_arena) {
      freeproxyconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, freeproxyconn, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.freeproxyconn_ = freeproxyconn;
  // @@protoc_insertion_point(field_set_allocated:NetMsg.freeProxyConn)
}

// optional .NotifyClientCreateProxyMsg notifyClientCreateProxy = 7;
inline bool NetMsg::_internal_has_notifyclientcreateproxy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.notifyclientcreateproxy_ != nullptr);
  return value;
}
inline bool NetMsg::has_notifyclientcreateproxy() const {
  return _internal_has_notifyclientcreateproxy();
}
inline void NetMsg::clear_notifyclientcreateproxy() {
  if (_impl_.notifyclientcreateproxy_ != nullptr) _impl_.notifyclientcreateproxy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::NotifyClientCreateProxyMsg& NetMsg::_internal_notifyclientcreateproxy() const {
  const ::NotifyClientCreateProxyMsg* p = _impl_.notifyclientcreateproxy_;
  return p != nullptr ? *p : reinterpret_cast<const ::NotifyClientCreateProxyMsg&>(
      ::_NotifyClientCreateProxyMsg_default_instance_);
}
inline const ::NotifyClientCreateProxyMsg& NetMsg::notifyclientcreateproxy() const {
  // @@protoc_insertion_point(field_get:NetMsg.notifyClientCreateProxy)
  return _internal_notifyclientcreateproxy();
}
inline void NetMsg::unsafe_arena_set_allocated_notifyclientcreateproxy(
    ::NotifyClientCreateProxyMsg* notifyclientcreateproxy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.notifyclientcreateproxy_);
  }
  _impl_.notifyclientcreateproxy_ = notifyclientcreateproxy;
  if (notifyclientcreateproxy) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NetMsg.notifyClientCreateProxy)
}
inline ::NotifyClientCreateProxyMsg* NetMsg::release_notifyclientcreateproxy() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::NotifyClientCreateProxyMsg* temp = _impl_.notifyclientcreateproxy_;
  _impl_.notifyclientcreateproxy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NotifyClientCreateProxyMsg* NetMsg::unsafe_arena_release_notifyclientcreateproxy() {
  // @@protoc_insertion_point(field_release:NetMsg.notifyClientCreateProxy)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::NotifyClientCreateProxyMsg* temp = _impl_.notifyclientcreateproxy_;
  _impl_.notifyclientcreateproxy_ = nullptr;
  return temp;
}
inline ::NotifyClientCreateProxyMsg* NetMsg::_internal_mutable_notifyclientcreateproxy() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.notifyclientcreateproxy_ == nullptr) {
    auto* p = CreateMaybeMessage<::NotifyClientCreateProxyMsg>(GetArenaForAllocation());
    _impl_.notifyclientcreateproxy_ = p;
  }
  return _impl_.notifyclientcreateproxy_;
}
inline ::NotifyClientCreateProxyMsg* NetMsg::mutable_notifyclientcreateproxy() {
  ::NotifyClientCreateProxyMsg* _msg = _internal_mutable_notifyclientcreateproxy();
  // @@protoc_insertion_point(field_mutable:NetMsg.notifyClientCreateProxy)
  return _msg;
}
inline void NetMsg::set_allocated_notifyclientcreateproxy(::NotifyClientCreateProxyMsg* notifyclientcreateproxy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.notifyclientcreateproxy_;
  }
  if (notifyclientcreateproxy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(notifyclientcreateproxy);
    if (message_arena != submessage_arena) {
      notifyclientcreateproxy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notifyclientcreateproxy, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.notifyclientcreateproxy_ = notifyclientcreateproxy;
  // @@protoc_insertion_point(field_set_allocated:NetMsg.notifyClientCreateProxy)
}

// optional .NotifyShutdownProxyMsg notifyShutdownProxy = 8;
inline bool NetMsg::_internal_has_notifyshutdownproxy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.notifyshutdownproxy_ != nullptr);
  return value;
}
inline bool NetMsg::has_notifyshutdownproxy() const {
  return _internal_has_notifyshutdownproxy();
}
inline void NetMsg::clear_notifyshutdownproxy() {
  if (_impl_.notifyshutdownproxy_ != nullptr) _impl_.notifyshutdownproxy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::NotifyShutdownProxyMsg& NetMsg::_internal_notifyshutdownproxy() const {
  const ::NotifyShutdownProxyMsg* p = _impl_.notifyshutdownproxy_;
  return p != nullptr ? *p : reinterpret_cast<const ::NotifyShutdownProxyMsg&>(
      ::_NotifyShutdownProxyMsg_default_instance_);
}
inline const ::NotifyShutdownProxyMsg& NetMsg::notifyshutdownproxy() const {
  // @@protoc_insertion_point(field_get:NetMsg.notifyShutdownProxy)
  return _internal_notifyshutdownproxy();
}
inline void NetMsg::unsafe_arena_set_allocated_notifyshutdownproxy(
    ::NotifyShutdownProxyMsg* notifyshutdownproxy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.notifyshutdownproxy_);
  }
  _impl_.notifyshutdownproxy_ = notifyshutdownproxy;
  if (notifyshutdownproxy) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NetMsg.notifyShutdownProxy)
}
inline ::NotifyShutdownProxyMsg* NetMsg::release_notifyshutdownproxy() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::NotifyShutdownProxyMsg* temp = _impl_.notifyshutdownproxy_;
  _impl_.notifyshutdownproxy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NotifyShutdownProxyMsg* NetMsg::unsafe_arena_release_notifyshutdownproxy() {
  // @@protoc_insertion_point(field_release:NetMsg.notifyShutdownProxy)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::NotifyShutdownProxyMsg* temp = _impl_.notifyshutdownproxy_;
  _impl_.notifyshutdownproxy_ = nullptr;
  return temp;
}
inline ::NotifyShutdownProxyMsg* NetMsg::_internal_mutable_notifyshutdownproxy() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.notifyshutdownproxy_ == nullptr) {
    auto* p = CreateMaybeMessage<::NotifyShutdownProxyMsg>(GetArenaForAllocation());
    _impl_.notifyshutdownproxy_ = p;
  }
  return _impl_.notifyshutdownproxy_;
}
inline ::NotifyShutdownProxyMsg* NetMsg::mutable_notifyshutdownproxy() {
  ::NotifyShutdownProxyMsg* _msg = _internal_mutable_notifyshutdownproxy();
  // @@protoc_insertion_point(field_mutable:NetMsg.notifyShutdownProxy)
  return _msg;
}
inline void NetMsg::set_allocated_notifyshutdownproxy(::NotifyShutdownProxyMsg* notifyshutdownproxy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.notifyshutdownproxy_;
  }
  if (notifyshutdownproxy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(notifyshutdownproxy);
    if (message_arena != submessage_arena) {
      notifyshutdownproxy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notifyshutdownproxy, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.notifyshutdownproxy_ = notifyshutdownproxy;
  // @@protoc_insertion_point(field_set_allocated:NetMsg.notifyShutdownProxy)
}

// optional .ClaimProxyConnMsg claimProxyConn = 9;
inline bool NetMsg::_internal_has_claimproxyconn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.claimproxyconn_ != nullptr);
  return value;
}
inline bool NetMsg::has_claimproxyconn() const {
  return _internal_has_claimproxyconn();
}
inline void NetMsg::clear_claimproxyconn() {
  if (_impl_.claimproxyconn_ != nullptr) _impl_.claimproxyconn_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::ClaimProxyConnMsg& NetMsg::_internal_claimproxyconn() const {
  const ::ClaimProxyConnMsg* p = _impl_.claimproxyconn_;
  return p != nullptr ? *p : reinterpret_cast<const ::ClaimProxyConnMsg&>(
      ::_ClaimProxyConnMsg_default_instance_);
}
inline const ::ClaimProxyConnMsg& NetMsg::claimproxyconn() const {
  // @@protoc_insertion_point(field_get:NetMsg.claimProxyConn)
  return _internal_claimproxyconn();
}
inline void NetMsg::unsafe_arena_set_allocated_claimproxyconn(
    ::ClaimProxyConnMsg* claimproxyconn) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.claimproxyconn_);
  }
  _impl_.claimproxyconn_ = claimproxyconn;
  if (claimproxyconn) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NetMsg.claimProxyConn)
}
inline ::ClaimProxyConnMsg* NetMsg::release_claimproxyconn() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::ClaimProxyConnMsg* temp = _impl_.claimproxyconn_;
  _impl_.claimproxyconn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ClaimProxyConnMsg* NetMsg::unsafe_arena_release_claimproxyconn() {
  // @@protoc_insertion_point(field_release:NetMsg.claimProxyConn)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::ClaimProxyConnMsg* temp = _impl_.claimproxyconn_;
  _impl_.claimproxyconn_ = nullptr;
  return temp;
}
inline ::ClaimProxyConnMsg* NetMsg::_internal_mutable_claimproxyconn() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.claimproxyconn_ == nullptr) {
    auto* p = CreateMaybeMessage<::ClaimProxyConnMsg>(GetArenaForAllocation());
    _impl_.claimproxyconn_ = p;
  }
  return _impl_.claimproxyconn_;
}
inline ::ClaimProxyConnMsg* NetMsg::mutable_claimproxyconn() {
  ::ClaimProxyConnMsg* _msg = _internal_mutable_claimproxyconn();
  // @@protoc_insertion_point(field_mutable:NetMsg.claimProxyConn)
  return _msg;
}
inline void NetMsg::set_allocated_claimproxyconn(::ClaimProxyConnMsg* claimproxyconn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.claimproxyconn_;
  }
  if (claimproxyconn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(claimproxyconn);
    if (message_arena != submessage_arena) {
      claimproxyconn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, claimproxyconn, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.claimproxyconn_ = claimproxyconn;
  // @@protoc_insertion_point(field_set_allocated:NetMsg.claimProxyConn)
}

// optional .StartProxyReqMsg startProxyReq = 10;
inline bool NetMsg::_internal_has_startproxyreq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.startproxyreq_ != nullptr);
  return value;
}
inline bool NetMsg::has_startproxyreq() const {
  return _internal_has_startproxyreq();
}
inline void NetMsg::clear_startproxyreq() {
  if (_impl_.startproxyreq_ != nullptr) _impl_.startproxyreq_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::StartProxyReqMsg& NetMsg::_internal_startproxyreq() const {
  const ::StartProxyReqMsg* p = _impl_.startproxyreq_;
  return p != nullptr ? *p : reinterpret_cast<const ::StartProxyReqMsg&>(
      ::_StartProxyReqMsg_default_instance_);
}
inline const ::StartProxyReqMsg& NetMsg::startproxyreq() const {
  // @@protoc_insertion_point(field_get:NetMsg.startProxyReq)
  return _internal_startproxyreq();
}
inline void NetMsg::unsafe_arena_set_allocated_startproxyreq(
    ::StartProxyReqMsg* startproxyreq) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.startproxyreq_);
  }
  _impl_.startproxyreq_ = startproxyreq;
  if (startproxyreq) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NetMsg.startProxyReq)
}
inline ::StartProxyReqMsg* NetMsg::release_startproxyreq() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::StartProxyReqMsg* temp = _impl_.startproxyreq_;
  _impl_.startproxyreq_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StartProxyReqMsg* NetMsg::unsafe_arena_release_startproxyreq() {
  // @@protoc_insertion_point(field_release:NetMsg.startProxyReq)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::StartProxyReqMsg* temp = _impl_.startproxyreq_;
  _impl_.startproxyreq_ = nullptr;
  return temp;
}
inline ::StartProxyReqMsg* NetMsg::_internal_mutable_startproxyreq() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.startproxyreq_ == nullptr) {
    auto* p = CreateMaybeMessage<::StartProxyReqMsg>(GetArenaForAllocation());
    _impl_.startproxyreq_ = p;
  }
  return _impl_.startproxyreq_;
}
inline ::StartProxyReqMsg* NetMsg::mutable_startproxyreq() {
  ::StartProxyReqMsg* _msg = _internal_mutable_startproxyreq();
  // @@protoc_insertion_point(field_mutable:NetMsg.startProxyReq)
  return _msg;
}
inline void NetMsg::set_allocated_startproxyreq(::StartProxyReqMsg* startproxyreq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.startproxyreq_;
  }
  if (startproxyreq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(startproxyreq);
    if (message_arena != submessage_arena) {
      startproxyreq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, startproxyreq, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.startproxyreq_ = startproxyreq;
  // @@protoc_insertion_point(field_set_allocated:NetMsg.startProxyReq)
}

// optional .StartProxyRspMsg startProxyRsp = 11;
inline bool NetMsg::_internal_has_startproxyrsp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.startproxyrsp_ != nullptr);
  return value;
}
inline bool NetMsg::has_startproxyrsp() const {
  return _internal_has_startproxyrsp();
}
inline void NetMsg::clear_startproxyrsp() {
  if (_impl_.startproxyrsp_ != nullptr) _impl_.startproxyrsp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::StartProxyRspMsg& NetMsg::_internal_startproxyrsp() const {
  const ::StartProxyRspMsg* p = _impl_.startproxyrsp_;
  return p != nullptr ? *p : reinterpret_cast<const ::StartProxyRspMsg&>(
      ::_StartProxyRspMsg_default_instance_);
}
inline const ::StartProxyRspMsg& NetMsg::startproxyrsp() const {
  // @@protoc_insertion_point(field_get:NetMsg.startProxyRsp)
  return _internal_startproxyrsp();
}
inline void NetMsg::unsafe_arena_set_allocated_startproxyrsp(
    ::StartProxyRspMsg* startproxyrsp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.startproxyrsp_);
  }
  _impl_.startproxyrsp_ = startproxyrsp;
  if (startproxyrsp) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NetMsg.startProxyRsp)
}
inline ::StartProxyRspMsg* NetMsg::release_startproxyrsp() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::StartProxyRspMsg* temp = _impl_.startproxyrsp_;
  _impl_.startproxyrsp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StartProxyRspMsg* NetMsg::unsafe_arena_release_startproxyrsp() {
  // @@protoc_insertion_point(field_release:NetMsg.startProxyRsp)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::StartProxyRspMsg* temp = _impl_.startproxyrsp_;
  _impl_.startproxyrsp_ = nullptr;
  return temp;
}
inline ::StartProxyRspMsg* NetMsg::_internal_mutable_startproxyrsp() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.startproxyrsp_ == nullptr) {
    auto* p = CreateMaybeMessage<::StartProxyRspMsg>(GetArenaForAllocation());
    _impl_.startproxyrsp_ = p;
  }
  return _impl_.startproxyrsp_;
}
inline ::StartProxyRspMsg* NetMsg::mutable_startproxyrsp() {
  ::StartProxyRspMsg* _msg = _internal_mutable_startproxyrsp();
  // @@protoc_insertion_point(field_mutable:NetMsg.startProxyRsp)
  return _msg;
}
inline void NetMsg::set_allocated_startproxyrsp(::StartProxyRspMsg* startproxyrsp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.startproxyrsp_;
  }
  if (startproxyrsp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(startproxyrsp);
    if (message_arena != submessage_arena) {
      startproxyrsp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, startproxyrsp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.startproxyrsp_ = startproxyrsp;
  // @@protoc_insertion_point(field_set_allocated:NetMsg.startProxyRsp)
}

// -------------------------------------------------------------------

// NewCtlReqMsg

// -------------------------------------------------------------------

// NewCtlRspMsg

// string ctl_id = 1;
inline void NewCtlRspMsg::clear_ctl_id() {
  _impl_.ctl_id_.ClearToEmpty();
}
inline const std::string& NewCtlRspMsg::ctl_id() const {
  // @@protoc_insertion_point(field_get:NewCtlRspMsg.ctl_id)
  return _internal_ctl_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewCtlRspMsg::set_ctl_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ctl_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NewCtlRspMsg.ctl_id)
}
inline std::string* NewCtlRspMsg::mutable_ctl_id() {
  std::string* _s = _internal_mutable_ctl_id();
  // @@protoc_insertion_point(field_mutable:NewCtlRspMsg.ctl_id)
  return _s;
}
inline const std::string& NewCtlRspMsg::_internal_ctl_id() const {
  return _impl_.ctl_id_.Get();
}
inline void NewCtlRspMsg::_internal_set_ctl_id(const std::string& value) {
  
  _impl_.ctl_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NewCtlRspMsg::_internal_mutable_ctl_id() {
  
  return _impl_.ctl_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NewCtlRspMsg::release_ctl_id() {
  // @@protoc_insertion_point(field_release:NewCtlRspMsg.ctl_id)
  return _impl_.ctl_id_.Release();
}
inline void NewCtlRspMsg::set_allocated_ctl_id(std::string* ctl_id) {
  if (ctl_id != nullptr) {
    
  } else {
    
  }
  _impl_.ctl_id_.SetAllocated(ctl_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ctl_id_.IsDefault()) {
    _impl_.ctl_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NewCtlRspMsg.ctl_id)
}

// -------------------------------------------------------------------

// NewTunnelReqMsg

// string local_server_host = 1;
inline void NewTunnelReqMsg::clear_local_server_host() {
  _impl_.local_server_host_.ClearToEmpty();
}
inline const std::string& NewTunnelReqMsg::local_server_host() const {
  // @@protoc_insertion_point(field_get:NewTunnelReqMsg.local_server_host)
  return _internal_local_server_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewTunnelReqMsg::set_local_server_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.local_server_host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NewTunnelReqMsg.local_server_host)
}
inline std::string* NewTunnelReqMsg::mutable_local_server_host() {
  std::string* _s = _internal_mutable_local_server_host();
  // @@protoc_insertion_point(field_mutable:NewTunnelReqMsg.local_server_host)
  return _s;
}
inline const std::string& NewTunnelReqMsg::_internal_local_server_host() const {
  return _impl_.local_server_host_.Get();
}
inline void NewTunnelReqMsg::_internal_set_local_server_host(const std::string& value) {
  
  _impl_.local_server_host_.Set(value, GetArenaForAllocation());
}
inline std::string* NewTunnelReqMsg::_internal_mutable_local_server_host() {
  
  return _impl_.local_server_host_.Mutable(GetArenaForAllocation());
}
inline std::string* NewTunnelReqMsg::release_local_server_host() {
  // @@protoc_insertion_point(field_release:NewTunnelReqMsg.local_server_host)
  return _impl_.local_server_host_.Release();
}
inline void NewTunnelReqMsg::set_allocated_local_server_host(std::string* local_server_host) {
  if (local_server_host != nullptr) {
    
  } else {
    
  }
  _impl_.local_server_host_.SetAllocated(local_server_host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.local_server_host_.IsDefault()) {
    _impl_.local_server_host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NewTunnelReqMsg.local_server_host)
}

// int32 local_server_port = 2;
inline void NewTunnelReqMsg::clear_local_server_port() {
  _impl_.local_server_port_ = 0;
}
inline int32_t NewTunnelReqMsg::_internal_local_server_port() const {
  return _impl_.local_server_port_;
}
inline int32_t NewTunnelReqMsg::local_server_port() const {
  // @@protoc_insertion_point(field_get:NewTunnelReqMsg.local_server_port)
  return _internal_local_server_port();
}
inline void NewTunnelReqMsg::_internal_set_local_server_port(int32_t value) {
  
  _impl_.local_server_port_ = value;
}
inline void NewTunnelReqMsg::set_local_server_port(int32_t value) {
  _internal_set_local_server_port(value);
  // @@protoc_insertion_point(field_set:NewTunnelReqMsg.local_server_port)
}

// -------------------------------------------------------------------

// NewTunnelRspMsg

// string tun_id = 1;
inline void NewTunnelRspMsg::clear_tun_id() {
  _impl_.tun_id_.ClearToEmpty();
}
inline const std::string& NewTunnelRspMsg::tun_id() const {
  // @@protoc_insertion_point(field_get:NewTunnelRspMsg.tun_id)
  return _internal_tun_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewTunnelRspMsg::set_tun_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tun_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NewTunnelRspMsg.tun_id)
}
inline std::string* NewTunnelRspMsg::mutable_tun_id() {
  std::string* _s = _internal_mutable_tun_id();
  // @@protoc_insertion_point(field_mutable:NewTunnelRspMsg.tun_id)
  return _s;
}
inline const std::string& NewTunnelRspMsg::_internal_tun_id() const {
  return _impl_.tun_id_.Get();
}
inline void NewTunnelRspMsg::_internal_set_tun_id(const std::string& value) {
  
  _impl_.tun_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NewTunnelRspMsg::_internal_mutable_tun_id() {
  
  return _impl_.tun_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NewTunnelRspMsg::release_tun_id() {
  // @@protoc_insertion_point(field_release:NewTunnelRspMsg.tun_id)
  return _impl_.tun_id_.Release();
}
inline void NewTunnelRspMsg::set_allocated_tun_id(std::string* tun_id) {
  if (tun_id != nullptr) {
    
  } else {
    
  }
  _impl_.tun_id_.SetAllocated(tun_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tun_id_.IsDefault()) {
    _impl_.tun_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NewTunnelRspMsg.tun_id)
}

// string local_server_host = 2;
inline void NewTunnelRspMsg::clear_local_server_host() {
  _impl_.local_server_host_.ClearToEmpty();
}
inline const std::string& NewTunnelRspMsg::local_server_host() const {
  // @@protoc_insertion_point(field_get:NewTunnelRspMsg.local_server_host)
  return _internal_local_server_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewTunnelRspMsg::set_local_server_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.local_server_host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NewTunnelRspMsg.local_server_host)
}
inline std::string* NewTunnelRspMsg::mutable_local_server_host() {
  std::string* _s = _internal_mutable_local_server_host();
  // @@protoc_insertion_point(field_mutable:NewTunnelRspMsg.local_server_host)
  return _s;
}
inline const std::string& NewTunnelRspMsg::_internal_local_server_host() const {
  return _impl_.local_server_host_.Get();
}
inline void NewTunnelRspMsg::_internal_set_local_server_host(const std::string& value) {
  
  _impl_.local_server_host_.Set(value, GetArenaForAllocation());
}
inline std::string* NewTunnelRspMsg::_internal_mutable_local_server_host() {
  
  return _impl_.local_server_host_.Mutable(GetArenaForAllocation());
}
inline std::string* NewTunnelRspMsg::release_local_server_host() {
  // @@protoc_insertion_point(field_release:NewTunnelRspMsg.local_server_host)
  return _impl_.local_server_host_.Release();
}
inline void NewTunnelRspMsg::set_allocated_local_server_host(std::string* local_server_host) {
  if (local_server_host != nullptr) {
    
  } else {
    
  }
  _impl_.local_server_host_.SetAllocated(local_server_host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.local_server_host_.IsDefault()) {
    _impl_.local_server_host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NewTunnelRspMsg.local_server_host)
}

// int32 local_server_port = 3;
inline void NewTunnelRspMsg::clear_local_server_port() {
  _impl_.local_server_port_ = 0;
}
inline int32_t NewTunnelRspMsg::_internal_local_server_port() const {
  return _impl_.local_server_port_;
}
inline int32_t NewTunnelRspMsg::local_server_port() const {
  // @@protoc_insertion_point(field_get:NewTunnelRspMsg.local_server_port)
  return _internal_local_server_port();
}
inline void NewTunnelRspMsg::_internal_set_local_server_port(int32_t value) {
  
  _impl_.local_server_port_ = value;
}
inline void NewTunnelRspMsg::set_local_server_port(int32_t value) {
  _internal_set_local_server_port(value);
  // @@protoc_insertion_point(field_set:NewTunnelRspMsg.local_server_port)
}

// string proxy_server_host = 4;
inline void NewTunnelRspMsg::clear_proxy_server_host() {
  _impl_.proxy_server_host_.ClearToEmpty();
}
inline const std::string& NewTunnelRspMsg::proxy_server_host() const {
  // @@protoc_insertion_point(field_get:NewTunnelRspMsg.proxy_server_host)
  return _internal_proxy_server_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewTunnelRspMsg::set_proxy_server_host(ArgT0&& arg0, ArgT... args) {
 
 _impl_.proxy_server_host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NewTunnelRspMsg.proxy_server_host)
}
inline std::string* NewTunnelRspMsg::mutable_proxy_server_host() {
  std::string* _s = _internal_mutable_proxy_server_host();
  // @@protoc_insertion_point(field_mutable:NewTunnelRspMsg.proxy_server_host)
  return _s;
}
inline const std::string& NewTunnelRspMsg::_internal_proxy_server_host() const {
  return _impl_.proxy_server_host_.Get();
}
inline void NewTunnelRspMsg::_internal_set_proxy_server_host(const std::string& value) {
  
  _impl_.proxy_server_host_.Set(value, GetArenaForAllocation());
}
inline std::string* NewTunnelRspMsg::_internal_mutable_proxy_server_host() {
  
  return _impl_.proxy_server_host_.Mutable(GetArenaForAllocation());
}
inline std::string* NewTunnelRspMsg::release_proxy_server_host() {
  // @@protoc_insertion_point(field_release:NewTunnelRspMsg.proxy_server_host)
  return _impl_.proxy_server_host_.Release();
}
inline void NewTunnelRspMsg::set_allocated_proxy_server_host(std::string* proxy_server_host) {
  if (proxy_server_host != nullptr) {
    
  } else {
    
  }
  _impl_.proxy_server_host_.SetAllocated(proxy_server_host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.proxy_server_host_.IsDefault()) {
    _impl_.proxy_server_host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NewTunnelRspMsg.proxy_server_host)
}

// int32 proxy_server_port = 5;
inline void NewTunnelRspMsg::clear_proxy_server_port() {
  _impl_.proxy_server_port_ = 0;
}
inline int32_t NewTunnelRspMsg::_internal_proxy_server_port() const {
  return _impl_.proxy_server_port_;
}
inline int32_t NewTunnelRspMsg::proxy_server_port() const {
  // @@protoc_insertion_point(field_get:NewTunnelRspMsg.proxy_server_port)
  return _internal_proxy_server_port();
}
inline void NewTunnelRspMsg::_internal_set_proxy_server_port(int32_t value) {
  
  _impl_.proxy_server_port_ = value;
}
inline void NewTunnelRspMsg::set_proxy_server_port(int32_t value) {
  _internal_set_proxy_server_port(value);
  // @@protoc_insertion_point(field_set:NewTunnelRspMsg.proxy_server_port)
}

// -------------------------------------------------------------------

// FreeProxyConnMsg

// string tun_id = 1;
inline void FreeProxyConnMsg::clear_tun_id() {
  _impl_.tun_id_.ClearToEmpty();
}
inline const std::string& FreeProxyConnMsg::tun_id() const {
  // @@protoc_insertion_point(field_get:FreeProxyConnMsg.tun_id)
  return _internal_tun_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FreeProxyConnMsg::set_tun_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tun_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FreeProxyConnMsg.tun_id)
}
inline std::string* FreeProxyConnMsg::mutable_tun_id() {
  std::string* _s = _internal_mutable_tun_id();
  // @@protoc_insertion_point(field_mutable:FreeProxyConnMsg.tun_id)
  return _s;
}
inline const std::string& FreeProxyConnMsg::_internal_tun_id() const {
  return _impl_.tun_id_.Get();
}
inline void FreeProxyConnMsg::_internal_set_tun_id(const std::string& value) {
  
  _impl_.tun_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FreeProxyConnMsg::_internal_mutable_tun_id() {
  
  return _impl_.tun_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FreeProxyConnMsg::release_tun_id() {
  // @@protoc_insertion_point(field_release:FreeProxyConnMsg.tun_id)
  return _impl_.tun_id_.Release();
}
inline void FreeProxyConnMsg::set_allocated_tun_id(std::string* tun_id) {
  if (tun_id != nullptr) {
    
  } else {
    
  }
  _impl_.tun_id_.SetAllocated(tun_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tun_id_.IsDefault()) {
    _impl_.tun_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FreeProxyConnMsg.tun_id)
}

// string TConn_id = 2;
inline void FreeProxyConnMsg::clear_tconn_id() {
  _impl_.tconn_id_.ClearToEmpty();
}
inline const std::string& FreeProxyConnMsg::tconn_id() const {
  // @@protoc_insertion_point(field_get:FreeProxyConnMsg.TConn_id)
  return _internal_tconn_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FreeProxyConnMsg::set_tconn_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tconn_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FreeProxyConnMsg.TConn_id)
}
inline std::string* FreeProxyConnMsg::mutable_tconn_id() {
  std::string* _s = _internal_mutable_tconn_id();
  // @@protoc_insertion_point(field_mutable:FreeProxyConnMsg.TConn_id)
  return _s;
}
inline const std::string& FreeProxyConnMsg::_internal_tconn_id() const {
  return _impl_.tconn_id_.Get();
}
inline void FreeProxyConnMsg::_internal_set_tconn_id(const std::string& value) {
  
  _impl_.tconn_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FreeProxyConnMsg::_internal_mutable_tconn_id() {
  
  return _impl_.tconn_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FreeProxyConnMsg::release_tconn_id() {
  // @@protoc_insertion_point(field_release:FreeProxyConnMsg.TConn_id)
  return _impl_.tconn_id_.Release();
}
inline void FreeProxyConnMsg::set_allocated_tconn_id(std::string* tconn_id) {
  if (tconn_id != nullptr) {
    
  } else {
    
  }
  _impl_.tconn_id_.SetAllocated(tconn_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tconn_id_.IsDefault()) {
    _impl_.tconn_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FreeProxyConnMsg.TConn_id)
}

// -------------------------------------------------------------------

// NotifyClientCreateProxyMsg

// string Tun_id = 1;
inline void NotifyClientCreateProxyMsg::clear_tun_id() {
  _impl_.tun_id_.ClearToEmpty();
}
inline const std::string& NotifyClientCreateProxyMsg::tun_id() const {
  // @@protoc_insertion_point(field_get:NotifyClientCreateProxyMsg.Tun_id)
  return _internal_tun_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NotifyClientCreateProxyMsg::set_tun_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tun_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NotifyClientCreateProxyMsg.Tun_id)
}
inline std::string* NotifyClientCreateProxyMsg::mutable_tun_id() {
  std::string* _s = _internal_mutable_tun_id();
  // @@protoc_insertion_point(field_mutable:NotifyClientCreateProxyMsg.Tun_id)
  return _s;
}
inline const std::string& NotifyClientCreateProxyMsg::_internal_tun_id() const {
  return _impl_.tun_id_.Get();
}
inline void NotifyClientCreateProxyMsg::_internal_set_tun_id(const std::string& value) {
  
  _impl_.tun_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NotifyClientCreateProxyMsg::_internal_mutable_tun_id() {
  
  return _impl_.tun_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NotifyClientCreateProxyMsg::release_tun_id() {
  // @@protoc_insertion_point(field_release:NotifyClientCreateProxyMsg.Tun_id)
  return _impl_.tun_id_.Release();
}
inline void NotifyClientCreateProxyMsg::set_allocated_tun_id(std::string* tun_id) {
  if (tun_id != nullptr) {
    
  } else {
    
  }
  _impl_.tun_id_.SetAllocated(tun_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tun_id_.IsDefault()) {
    _impl_.tun_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NotifyClientCreateProxyMsg.Tun_id)
}

// int32 server_proxy_port = 2;
inline void NotifyClientCreateProxyMsg::clear_server_proxy_port() {
  _impl_.server_proxy_port_ = 0;
}
inline int32_t NotifyClientCreateProxyMsg::_internal_server_proxy_port() const {
  return _impl_.server_proxy_port_;
}
inline int32_t NotifyClientCreateProxyMsg::server_proxy_port() const {
  // @@protoc_insertion_point(field_get:NotifyClientCreateProxyMsg.server_proxy_port)
  return _internal_server_proxy_port();
}
inline void NotifyClientCreateProxyMsg::_internal_set_server_proxy_port(int32_t value) {
  
  _impl_.server_proxy_port_ = value;
}
inline void NotifyClientCreateProxyMsg::set_server_proxy_port(int32_t value) {
  _internal_set_server_proxy_port(value);
  // @@protoc_insertion_point(field_set:NotifyClientCreateProxyMsg.server_proxy_port)
}

// -------------------------------------------------------------------

// NotifyShutdownProxyMsg

// string Tun_id = 1;
inline void NotifyShutdownProxyMsg::clear_tun_id() {
  _impl_.tun_id_.ClearToEmpty();
}
inline const std::string& NotifyShutdownProxyMsg::tun_id() const {
  // @@protoc_insertion_point(field_get:NotifyShutdownProxyMsg.Tun_id)
  return _internal_tun_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NotifyShutdownProxyMsg::set_tun_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tun_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NotifyShutdownProxyMsg.Tun_id)
}
inline std::string* NotifyShutdownProxyMsg::mutable_tun_id() {
  std::string* _s = _internal_mutable_tun_id();
  // @@protoc_insertion_point(field_mutable:NotifyShutdownProxyMsg.Tun_id)
  return _s;
}
inline const std::string& NotifyShutdownProxyMsg::_internal_tun_id() const {
  return _impl_.tun_id_.Get();
}
inline void NotifyShutdownProxyMsg::_internal_set_tun_id(const std::string& value) {
  
  _impl_.tun_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NotifyShutdownProxyMsg::_internal_mutable_tun_id() {
  
  return _impl_.tun_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NotifyShutdownProxyMsg::release_tun_id() {
  // @@protoc_insertion_point(field_release:NotifyShutdownProxyMsg.Tun_id)
  return _impl_.tun_id_.Release();
}
inline void NotifyShutdownProxyMsg::set_allocated_tun_id(std::string* tun_id) {
  if (tun_id != nullptr) {
    
  } else {
    
  }
  _impl_.tun_id_.SetAllocated(tun_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tun_id_.IsDefault()) {
    _impl_.tun_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NotifyShutdownProxyMsg.Tun_id)
}

// string TConn_id = 2;
inline void NotifyShutdownProxyMsg::clear_tconn_id() {
  _impl_.tconn_id_.ClearToEmpty();
}
inline const std::string& NotifyShutdownProxyMsg::tconn_id() const {
  // @@protoc_insertion_point(field_get:NotifyShutdownProxyMsg.TConn_id)
  return _internal_tconn_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NotifyShutdownProxyMsg::set_tconn_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tconn_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NotifyShutdownProxyMsg.TConn_id)
}
inline std::string* NotifyShutdownProxyMsg::mutable_tconn_id() {
  std::string* _s = _internal_mutable_tconn_id();
  // @@protoc_insertion_point(field_mutable:NotifyShutdownProxyMsg.TConn_id)
  return _s;
}
inline const std::string& NotifyShutdownProxyMsg::_internal_tconn_id() const {
  return _impl_.tconn_id_.Get();
}
inline void NotifyShutdownProxyMsg::_internal_set_tconn_id(const std::string& value) {
  
  _impl_.tconn_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NotifyShutdownProxyMsg::_internal_mutable_tconn_id() {
  
  return _impl_.tconn_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NotifyShutdownProxyMsg::release_tconn_id() {
  // @@protoc_insertion_point(field_release:NotifyShutdownProxyMsg.TConn_id)
  return _impl_.tconn_id_.Release();
}
inline void NotifyShutdownProxyMsg::set_allocated_tconn_id(std::string* tconn_id) {
  if (tconn_id != nullptr) {
    
  } else {
    
  }
  _impl_.tconn_id_.SetAllocated(tconn_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tconn_id_.IsDefault()) {
    _impl_.tconn_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NotifyShutdownProxyMsg.TConn_id)
}

// int32 tran_count = 3;
inline void NotifyShutdownProxyMsg::clear_tran_count() {
  _impl_.tran_count_ = 0;
}
inline int32_t NotifyShutdownProxyMsg::_internal_tran_count() const {
  return _impl_.tran_count_;
}
inline int32_t NotifyShutdownProxyMsg::tran_count() const {
  // @@protoc_insertion_point(field_get:NotifyShutdownProxyMsg.tran_count)
  return _internal_tran_count();
}
inline void NotifyShutdownProxyMsg::_internal_set_tran_count(int32_t value) {
  
  _impl_.tran_count_ = value;
}
inline void NotifyShutdownProxyMsg::set_tran_count(int32_t value) {
  _internal_set_tran_count(value);
  // @@protoc_insertion_point(field_set:NotifyShutdownProxyMsg.tran_count)
}

// -------------------------------------------------------------------

// ClaimProxyConnMsg

// string ctl_id = 1;
inline void ClaimProxyConnMsg::clear_ctl_id() {
  _impl_.ctl_id_.ClearToEmpty();
}
inline const std::string& ClaimProxyConnMsg::ctl_id() const {
  // @@protoc_insertion_point(field_get:ClaimProxyConnMsg.ctl_id)
  return _internal_ctl_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClaimProxyConnMsg::set_ctl_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ctl_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClaimProxyConnMsg.ctl_id)
}
inline std::string* ClaimProxyConnMsg::mutable_ctl_id() {
  std::string* _s = _internal_mutable_ctl_id();
  // @@protoc_insertion_point(field_mutable:ClaimProxyConnMsg.ctl_id)
  return _s;
}
inline const std::string& ClaimProxyConnMsg::_internal_ctl_id() const {
  return _impl_.ctl_id_.Get();
}
inline void ClaimProxyConnMsg::_internal_set_ctl_id(const std::string& value) {
  
  _impl_.ctl_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClaimProxyConnMsg::_internal_mutable_ctl_id() {
  
  return _impl_.ctl_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ClaimProxyConnMsg::release_ctl_id() {
  // @@protoc_insertion_point(field_release:ClaimProxyConnMsg.ctl_id)
  return _impl_.ctl_id_.Release();
}
inline void ClaimProxyConnMsg::set_allocated_ctl_id(std::string* ctl_id) {
  if (ctl_id != nullptr) {
    
  } else {
    
  }
  _impl_.ctl_id_.SetAllocated(ctl_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ctl_id_.IsDefault()) {
    _impl_.ctl_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClaimProxyConnMsg.ctl_id)
}

// string tun_id = 2;
inline void ClaimProxyConnMsg::clear_tun_id() {
  _impl_.tun_id_.ClearToEmpty();
}
inline const std::string& ClaimProxyConnMsg::tun_id() const {
  // @@protoc_insertion_point(field_get:ClaimProxyConnMsg.tun_id)
  return _internal_tun_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClaimProxyConnMsg::set_tun_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tun_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClaimProxyConnMsg.tun_id)
}
inline std::string* ClaimProxyConnMsg::mutable_tun_id() {
  std::string* _s = _internal_mutable_tun_id();
  // @@protoc_insertion_point(field_mutable:ClaimProxyConnMsg.tun_id)
  return _s;
}
inline const std::string& ClaimProxyConnMsg::_internal_tun_id() const {
  return _impl_.tun_id_.Get();
}
inline void ClaimProxyConnMsg::_internal_set_tun_id(const std::string& value) {
  
  _impl_.tun_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClaimProxyConnMsg::_internal_mutable_tun_id() {
  
  return _impl_.tun_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ClaimProxyConnMsg::release_tun_id() {
  // @@protoc_insertion_point(field_release:ClaimProxyConnMsg.tun_id)
  return _impl_.tun_id_.Release();
}
inline void ClaimProxyConnMsg::set_allocated_tun_id(std::string* tun_id) {
  if (tun_id != nullptr) {
    
  } else {
    
  }
  _impl_.tun_id_.SetAllocated(tun_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tun_id_.IsDefault()) {
    _impl_.tun_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClaimProxyConnMsg.tun_id)
}

// string TConn_id = 3;
inline void ClaimProxyConnMsg::clear_tconn_id() {
  _impl_.tconn_id_.ClearToEmpty();
}
inline const std::string& ClaimProxyConnMsg::tconn_id() const {
  // @@protoc_insertion_point(field_get:ClaimProxyConnMsg.TConn_id)
  return _internal_tconn_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClaimProxyConnMsg::set_tconn_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tconn_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClaimProxyConnMsg.TConn_id)
}
inline std::string* ClaimProxyConnMsg::mutable_tconn_id() {
  std::string* _s = _internal_mutable_tconn_id();
  // @@protoc_insertion_point(field_mutable:ClaimProxyConnMsg.TConn_id)
  return _s;
}
inline const std::string& ClaimProxyConnMsg::_internal_tconn_id() const {
  return _impl_.tconn_id_.Get();
}
inline void ClaimProxyConnMsg::_internal_set_tconn_id(const std::string& value) {
  
  _impl_.tconn_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClaimProxyConnMsg::_internal_mutable_tconn_id() {
  
  return _impl_.tconn_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ClaimProxyConnMsg::release_tconn_id() {
  // @@protoc_insertion_point(field_release:ClaimProxyConnMsg.TConn_id)
  return _impl_.tconn_id_.Release();
}
inline void ClaimProxyConnMsg::set_allocated_tconn_id(std::string* tconn_id) {
  if (tconn_id != nullptr) {
    
  } else {
    
  }
  _impl_.tconn_id_.SetAllocated(tconn_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tconn_id_.IsDefault()) {
    _impl_.tconn_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClaimProxyConnMsg.TConn_id)
}

// -------------------------------------------------------------------

// StartProxyReqMsg

// string TConn_id = 1;
inline void StartProxyReqMsg::clear_tconn_id() {
  _impl_.tconn_id_.ClearToEmpty();
}
inline const std::string& StartProxyReqMsg::tconn_id() const {
  // @@protoc_insertion_point(field_get:StartProxyReqMsg.TConn_id)
  return _internal_tconn_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartProxyReqMsg::set_tconn_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tconn_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StartProxyReqMsg.TConn_id)
}
inline std::string* StartProxyReqMsg::mutable_tconn_id() {
  std::string* _s = _internal_mutable_tconn_id();
  // @@protoc_insertion_point(field_mutable:StartProxyReqMsg.TConn_id)
  return _s;
}
inline const std::string& StartProxyReqMsg::_internal_tconn_id() const {
  return _impl_.tconn_id_.Get();
}
inline void StartProxyReqMsg::_internal_set_tconn_id(const std::string& value) {
  
  _impl_.tconn_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StartProxyReqMsg::_internal_mutable_tconn_id() {
  
  return _impl_.tconn_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StartProxyReqMsg::release_tconn_id() {
  // @@protoc_insertion_point(field_release:StartProxyReqMsg.TConn_id)
  return _impl_.tconn_id_.Release();
}
inline void StartProxyReqMsg::set_allocated_tconn_id(std::string* tconn_id) {
  if (tconn_id != nullptr) {
    
  } else {
    
  }
  _impl_.tconn_id_.SetAllocated(tconn_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tconn_id_.IsDefault()) {
    _impl_.tconn_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StartProxyReqMsg.TConn_id)
}

// string PublicWaitConnid = 2;
inline void StartProxyReqMsg::clear_publicwaitconnid() {
  _impl_.publicwaitconnid_.ClearToEmpty();
}
inline const std::string& StartProxyReqMsg::publicwaitconnid() const {
  // @@protoc_insertion_point(field_get:StartProxyReqMsg.PublicWaitConnid)
  return _internal_publicwaitconnid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartProxyReqMsg::set_publicwaitconnid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.publicwaitconnid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StartProxyReqMsg.PublicWaitConnid)
}
inline std::string* StartProxyReqMsg::mutable_publicwaitconnid() {
  std::string* _s = _internal_mutable_publicwaitconnid();
  // @@protoc_insertion_point(field_mutable:StartProxyReqMsg.PublicWaitConnid)
  return _s;
}
inline const std::string& StartProxyReqMsg::_internal_publicwaitconnid() const {
  return _impl_.publicwaitconnid_.Get();
}
inline void StartProxyReqMsg::_internal_set_publicwaitconnid(const std::string& value) {
  
  _impl_.publicwaitconnid_.Set(value, GetArenaForAllocation());
}
inline std::string* StartProxyReqMsg::_internal_mutable_publicwaitconnid() {
  
  return _impl_.publicwaitconnid_.Mutable(GetArenaForAllocation());
}
inline std::string* StartProxyReqMsg::release_publicwaitconnid() {
  // @@protoc_insertion_point(field_release:StartProxyReqMsg.PublicWaitConnid)
  return _impl_.publicwaitconnid_.Release();
}
inline void StartProxyReqMsg::set_allocated_publicwaitconnid(std::string* publicwaitconnid) {
  if (publicwaitconnid != nullptr) {
    
  } else {
    
  }
  _impl_.publicwaitconnid_.SetAllocated(publicwaitconnid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publicwaitconnid_.IsDefault()) {
    _impl_.publicwaitconnid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StartProxyReqMsg.PublicWaitConnid)
}

// -------------------------------------------------------------------

// StartProxyRspMsg

// string PublicWaitConnid = 1;
inline void StartProxyRspMsg::clear_publicwaitconnid() {
  _impl_.publicwaitconnid_.ClearToEmpty();
}
inline const std::string& StartProxyRspMsg::publicwaitconnid() const {
  // @@protoc_insertion_point(field_get:StartProxyRspMsg.PublicWaitConnid)
  return _internal_publicwaitconnid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartProxyRspMsg::set_publicwaitconnid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.publicwaitconnid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StartProxyRspMsg.PublicWaitConnid)
}
inline std::string* StartProxyRspMsg::mutable_publicwaitconnid() {
  std::string* _s = _internal_mutable_publicwaitconnid();
  // @@protoc_insertion_point(field_mutable:StartProxyRspMsg.PublicWaitConnid)
  return _s;
}
inline const std::string& StartProxyRspMsg::_internal_publicwaitconnid() const {
  return _impl_.publicwaitconnid_.Get();
}
inline void StartProxyRspMsg::_internal_set_publicwaitconnid(const std::string& value) {
  
  _impl_.publicwaitconnid_.Set(value, GetArenaForAllocation());
}
inline std::string* StartProxyRspMsg::_internal_mutable_publicwaitconnid() {
  
  return _impl_.publicwaitconnid_.Mutable(GetArenaForAllocation());
}
inline std::string* StartProxyRspMsg::release_publicwaitconnid() {
  // @@protoc_insertion_point(field_release:StartProxyRspMsg.PublicWaitConnid)
  return _impl_.publicwaitconnid_.Release();
}
inline void StartProxyRspMsg::set_allocated_publicwaitconnid(std::string* publicwaitconnid) {
  if (publicwaitconnid != nullptr) {
    
  } else {
    
  }
  _impl_.publicwaitconnid_.SetAllocated(publicwaitconnid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publicwaitconnid_.IsDefault()) {
    _impl_.publicwaitconnid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StartProxyRspMsg.PublicWaitConnid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MessageType>() {
  return ::MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Proxy_2eproto
